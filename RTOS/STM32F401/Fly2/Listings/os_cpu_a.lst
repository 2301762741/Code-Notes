


ARM Macro Assembler    Page 1 


    1 00000000         ;;
    2 00000000         ;;******************************************************
                       **************************************************
    3 00000000         ;;                                                uC/OS-
                       II
    4 00000000         ;;                                          The Real-Tim
                       e Kernel
    5 00000000         ;;
    6 00000000         ;;
    7 00000000         ;;                         (c) Copyright 2009-2013; Micr
                       ium, Inc.; Weston, FL
    8 00000000         ;;                    All rights reserved.  Protected by
                        international copyright laws.
    9 00000000         ;;
   10 00000000         ;;                                           ARM Cortex-
                       M4 Port
   11 00000000         ;;
   12 00000000         ;; File      : OS_CPU_A.ASM
   13 00000000         ;; Version   : V2.92.09
   14 00000000         ;; By        : JJL
   15 00000000         ;;             BAN
   16 00000000         ;;             JBL
   17 00000000         ;;
   18 00000000         ;; For       : ARMv7 Cortex-M4
   19 00000000         ;; Mode      : Thumb-2 ISA
   20 00000000         ;; Toolchain : IAR EWARM
   21 00000000         ;;******************************************************
                       **************************************************
   22 00000000         ;;
   23 00000000         
   24 00000000         ;;******************************************************
                       **************************************************
   25 00000000         ;;                                          PUBLIC FUNCT
                       IONS
   26 00000000         ;;******************************************************
                       **************************************************
   27 00000000         
   28 00000000         ;    IMPORT  OSRunning                                  
                                ; External references
   29 00000000         ;    IMPORT  OSPrioCur
   30 00000000         ;    IMPORT  OSPrioHighRdy
   31 00000000         ;    IMPORT  OSTCBCur
   32 00000000         ;    IMPORT  OSTCBHighRdy
   33 00000000         ;    IMPORT  OSIntExit
   34 00000000         ;    IMPORT  OSTaskSwHook
   35 00000000         ;    IMPORT  OS_CPU_ExceptStkBase
   36 00000000         
   37 00000000         ;    EXPORT  OS_CPU_SR_Save                             
                                ; Functions declared in this file
   38 00000000         ;    EXPORT  OS_CPU_SR_Restore
   39 00000000         ;    EXPORT  OSStartHighRdy
   40 00000000         ;    EXPORT  OSCtxSw
   41 00000000         ;    EXPORT  OSIntCtxSw
   42 00000000         ;    EXPORT  PendSV_Handler
   43 00000000         ;    
   44 00000000         ;  
   45 00000000         
   46 00000000         ;  
   47 00000000         ;;******************************************************



ARM Macro Assembler    Page 2 


                       **************************************************
   48 00000000         ;;                                               EQUATES
                       
   49 00000000         ;;******************************************************
                       **************************************************
   50 00000000         
   51 00000000         ;NVIC_INT_CTRL   EQU     0xE000ED04                     
                                ; Interrupt control state register.
   52 00000000         ;NVIC_SYSPRI14   EQU     0xE000ED22                     
                                ; System priority register (priority 14).
   53 00000000         ;NVIC_PENDSV_PRI EQU           0xFF                     
                                ; PendSV priority value (lowest).
   54 00000000         ;NVIC_PENDSVSET  EQU     0x10000000                     
                                ; Value to trigger PendSV exception.
   55 00000000         
   56 00000000         
   57 00000000         ;;******************************************************
                       **************************************************
   58 00000000         ;;                                     CODE GENERATION D
                       IRECTIVES
   59 00000000         ;;******************************************************
                       **************************************************
   60 00000000         ;  PRESERVE8  
   61 00000000         ;  AREA    |.text|, CODE, READONLY
   62 00000000         ;        THUMB
   63 00000000         ;   
   64 00000000         ;#ifdef __ARMVFP__  
   65 00000000         ;    EXPORT  OS_CPU_FP_Reg_Push
   66 00000000         ;    EXPORT  OS_CPU_FP_Reg_Pop
   67 00000000         ;#endif    
   68 00000000         
   69 00000000         
   70 00000000         ;;******************************************************
                       **************************************************
   71 00000000         ;;                                   FLOATING POINT REGI
                       STERS PUSH
   72 00000000         ;;                             void  OS_CPU_FP_Reg_Push 
                       (OS_STK  *stkPtr)
   73 00000000         ;;
   74 00000000         ;; Note(s) : 1) This function saves S0-S31, and FPSCR re
                       gisters of the Floating Point Unit.
   75 00000000         ;;
   76 00000000         ;;           2) Pseudo-code is:
   77 00000000         ;;              a) Get FPSCR register value;
   78 00000000         ;;              b) Push value on process stack;
   79 00000000         ;;              c) Push remaining regs S0-S31 on process
                        stack;
   80 00000000         ;;              d) Update OSTCBCur->OSTCBStkPtr;
   81 00000000         ;;******************************************************
                       **************************************************
   82 00000000         
   83 00000000         ;#ifdef __ARMVFP__
   84 00000000         ;OS_CPU_FP_Reg_Push
   85 00000000         ;    MRS     R1, PSP                                    
                                ; PSP is process stack pointer
   86 00000000         ;    CBZ     R1, OS_CPU_FP_nosave                       
                                ; Skip FP register save the first time
   87 00000000         ;    
   88 00000000         ;    VMRS    R1, FPSCR



ARM Macro Assembler    Page 3 


   89 00000000         ;    STR R1, [R0, #-4]!
   90 00000000         ;    VSTMDB  R0!, {S0-S31}
   91 00000000         ;    LDR     R1, =OSTCBCur
   92 00000000         ;    LDR     R2, [R1]
   93 00000000         ;    STR     R0, [R2]
   94 00000000         ;OS_CPU_FP_nosave    
   95 00000000         ;    BX      LR
   96 00000000         ;#endif
   97 00000000         
   98 00000000         
   99 00000000         ;;******************************************************
                       **************************************************
  100 00000000         ;;                                   FLOATING POINT REGI
                       STERS POP
  101 00000000         ;;                             void  OS_CPU_FP_Reg_Pop (
                       OS_STK  *stkPtr)
  102 00000000         ;;
  103 00000000         ;; Note(s) : 1) This function restores S0-S31, and FPSCR
                        registers of the Floating Point Unit.
  104 00000000         ;;
  105 00000000         ;;           2) Pseudo-code is:
  106 00000000         ;;              a) Restore regs S0-S31 of new process st
                       ack;
  107 00000000         ;;              b) Restore FPSCR reg value
  108 00000000         ;;              c) Update OSTCBHighRdy->OSTCBStkPtr poin
                       ter of new proces stack;
  109 00000000         ;;******************************************************
                       **************************************************
  110 00000000         
  111 00000000         ;#ifdef __ARMVFP__
  112 00000000         ;OS_CPU_FP_Reg_Pop
  113 00000000         ;    VLDMIA  R0!, {S0-S31}
  114 00000000         ;    LDMIA   R0!, {R1}
  115 00000000         ;    VMSR    FPSCR, R1    
  116 00000000         ;    LDR     R1, =OSTCBHighRdy
  117 00000000         ;    LDR     R2, [R1]
  118 00000000         ;    STR     R0, [R2]
  119 00000000         ;    BX      LR
  120 00000000         ;#endif
  121 00000000         
  122 00000000         
  123 00000000         ;;******************************************************
                       **************************************************
  124 00000000         ;;                                   CRITICAL SECTION ME
                       THOD 3 FUNCTIONS
  125 00000000         ;;
  126 00000000         ;; Description: Disable/Enable interrupts by preserving 
                       the state of interrupts.  Generally speaking you
  127 00000000         ;;              would store the state of the interrupt d
                       isable flag in the local variable 'cpu_sr' and then
  128 00000000         ;;              disable interrupts.  'cpu_sr' is allocat
                       ed in all of uC/OS-II's functions that need to
  129 00000000         ;;              disable interrupts.  You would restore t
                       he interrupt disable state by copying back 'cpu_sr'
  130 00000000         ;;              into the CPU's status register.
  131 00000000         ;;
  132 00000000         ;; Prototypes :     OS_CPU_SR  OS_CPU_SR_Save(void);
  133 00000000         ;;                  void       OS_CPU_SR_Restore(OS_CPU_
                       SR cpu_sr);



ARM Macro Assembler    Page 4 


  134 00000000         ;;
  135 00000000         ;;
  136 00000000         ;; Note(s)    : 1) These functions are used in general l
                       ike this:
  137 00000000         ;;
  138 00000000         ;;                 void Task (void *p_arg)
  139 00000000         ;;                 {
  140 00000000         ;;                 #if OS_CRITICAL_METHOD == 3          
                       /* Allocate storage for CPU status register */
  141 00000000         ;;                     OS_CPU_SR  cpu_sr;
  142 00000000         ;;                 #endif
  143 00000000         ;;
  144 00000000         ;;                          :
  145 00000000         ;;                          :
  146 00000000         ;;                     OS_ENTER_CRITICAL();             
                       /* cpu_sr = OS_CPU_SaveSR();                */
  147 00000000         ;;                          :
  148 00000000         ;;                          :
  149 00000000         ;;                     OS_EXIT_CRITICAL();              
                       /* OS_CPU_RestoreSR(cpu_sr);                */
  150 00000000         ;;                          :
  151 00000000         ;;                          :
  152 00000000         ;;                 }
  153 00000000         ;;******************************************************
                       **************************************************
  154 00000000         
  155 00000000         ;OS_CPU_SR_Save
  156 00000000         ;    MRS     R0, PRIMASK                                
                                ; Set prio int mask to mask all (except faults)
                       
  157 00000000         ;    CPSID   I
  158 00000000         ;    BX      LR
  159 00000000         
  160 00000000         ;OS_CPU_SR_Restore
  161 00000000         ;    MSR     PRIMASK, R0
  162 00000000         ;    BX      LR
  163 00000000         
  164 00000000         
  165 00000000         ;;******************************************************
                       **************************************************
  166 00000000         ;;                                         START MULTITA
                       SKING
  167 00000000         ;;                                      void OSStartHigh
                       Rdy(void)
  168 00000000         ;;
  169 00000000         ;; Note(s) : 1) This function triggers a PendSV exceptio
                       n (essentially, causes a context switch) to cause
  170 00000000         ;;              the first task to start.
  171 00000000         ;;
  172 00000000         ;;           2) OSStartHighRdy() MUST:
  173 00000000         ;;              a) Setup PendSV exception priority to lo
                       west;
  174 00000000         ;;              b) Set initial PSP to 0, to tell context
                        switcher this is first run;
  175 00000000         ;;              c) Set the main stack to OS_CPU_ExceptSt
                       kBase
  176 00000000         ;;              d) Set OSRunning to TRUE;
  177 00000000         ;;              e) Trigger PendSV exception;
  178 00000000         ;;              f) Enable interrupts (tasks will run wit



ARM Macro Assembler    Page 5 


                       h interrupts enabled).
  179 00000000         ;;******************************************************
                       **************************************************
  180 00000000         
  181 00000000         ;OSStartHighRdy
  182 00000000         ;    LDR     R0, =NVIC_SYSPRI14                         
                                ; Set the PendSV exception priority
  183 00000000         ;    LDR     R1, =NVIC_PENDSV_PRI
  184 00000000         ;    STRB    R1, [R0]
  185 00000000         
  186 00000000         ;    MOVS    R0, #0                                     
                                ; Set the PSP to 0 for initial context switch c
                       all
  187 00000000         ;    MSR     PSP, R0
  188 00000000         
  189 00000000         ;    LDR     R0, =OS_CPU_ExceptStkBase                  
                                ; Initialize the MSP to the OS_CPU_ExceptStkBas
                       e
  190 00000000         ;    LDR     R1, [R0]
  191 00000000         ;    MSR     MSP, R1    
  192 00000000         
  193 00000000         ;    LDR     R0, =OSRunning                             
                                ; OSRunning = TRUE
  194 00000000         ;    MOVS    R1, #1
  195 00000000         ;    STRB    R1, [R0]
  196 00000000         
  197 00000000         ;    LDR     R0, =NVIC_INT_CTRL                         
                                ; Trigger the PendSV exception (causes context 
                       switch)
  198 00000000         ;    LDR     R1, =NVIC_PENDSVSET
  199 00000000         ;    STR     R1, [R0]
  200 00000000         
  201 00000000         ;    CPSIE   I                                          
                                ; Enable interrupts at processor level
  202 00000000         
  203 00000000         ;OSStartHang
  204 00000000         ;    B       OSStartHang                                
                                ; Should never get here
  205 00000000         
  206 00000000         
  207 00000000         ;;******************************************************
                       **************************************************
  208 00000000         ;;                       PERFORM A CONTEXT SWITCH (From 
                       task level) - OSCtxSw()
  209 00000000         ;;
  210 00000000         ;; Note(s) : 1) OSCtxSw() is called when OS wants to per
                       form a task context switch.  This function
  211 00000000         ;;              triggers the PendSV exception which is w
                       here the real work is done.
  212 00000000         ;;******************************************************
                       **************************************************
  213 00000000         
  214 00000000         ;OSCtxSw
  215 00000000         ;    LDR     R0, =NVIC_INT_CTRL                         
                                ; Trigger the PendSV exception (causes context 
                       switch)
  216 00000000         ;    LDR     R1, =NVIC_PENDSVSET
  217 00000000         ;    STR     R1, [R0]
  218 00000000         ;    BX      LR



ARM Macro Assembler    Page 6 


  219 00000000         
  220 00000000         
  221 00000000         ;;******************************************************
                       **************************************************
  222 00000000         ;;                   PERFORM A CONTEXT SWITCH (From inte
                       rrupt level) - OSIntCtxSw()
  223 00000000         ;;
  224 00000000         ;; Note(s) : 1) OSIntCtxSw() is called by OSIntExit() wh
                       en it determines a context switch is needed as
  225 00000000         ;;              the result of an interrupt.  This functi
                       on simply triggers a PendSV exception which will
  226 00000000         ;;              be handled when there are no more interr
                       upts active and interrupts are enabled.
  227 00000000         ;;******************************************************
                       **************************************************
  228 00000000         
  229 00000000         ;OSIntCtxSw
  230 00000000         ;    LDR     R0, =NVIC_INT_CTRL                         
                                ; Trigger the PendSV exception (causes context 
                       switch)
  231 00000000         ;    LDR     R1, =NVIC_PENDSVSET
  232 00000000         ;    STR     R1, [R0]
  233 00000000         ;    BX      LR
  234 00000000         
  235 00000000         
  236 00000000         ;;******************************************************
                       **************************************************
  237 00000000         ;;                                       HANDLE PendSV E
                       XCEPTION
  238 00000000         ;;                                   void OS_CPU_PendSVH
                       andler(void)
  239 00000000         ;;
  240 00000000         ;; Note(s) : 1) PendSV is used to cause a context switch
                       .  This is a recommended method for performing
  241 00000000         ;;              context switches with Cortex-M3.  This i
                       s because the Cortex-M3 auto-saves half of the
  242 00000000         ;;              processor context on any exception, and 
                       restores same on return from exception.  So only
  243 00000000         ;;              saving of R4-R11 is required and fixing 
                       up the stack pointers.  Using the PendSV exception
  244 00000000         ;;              this way means that context saving and r
                       estoring is identical whether it is initiated from
  245 00000000         ;;              a thread or occurs due to an interrupt o
                       r exception.
  246 00000000         ;;
  247 00000000         ;;           2) Pseudo-code is:
  248 00000000         ;;              a) Get the process SP, if 0 then skip (g
                       oto d) the saving part (first context switch);
  249 00000000         ;;              b) Save remaining regs r4-r11 on process
                        stack;
  250 00000000         ;;              c) Save the process SP in its TCB, OSTCB
                       Cur->OSTCBStkPtr = SP;
  251 00000000         ;;              d) Call OSTaskSwHook();
  252 00000000         ;;              e) Get current high priority, OSPrioCur 
                       = OSPrioHighRdy;
  253 00000000         ;;              f) Get current ready thread TCB, OSTCBCu
                       r = OSTCBHighRdy;
  254 00000000         ;;              g) Get new process SP from TCB, SP = OST
                       CBHighRdy->OSTCBStkPtr;



ARM Macro Assembler    Page 7 


  255 00000000         ;;              h) Restore R4-R11 from new process stack
                       ;
  256 00000000         ;;              i) Perform exception return which will r
                       estore remaining context.
  257 00000000         ;;
  258 00000000         ;;           3) On entry into PendSV handler:
  259 00000000         ;;              a) The following have been saved on the 
                       process stack (by processor):
  260 00000000         ;;                 xPSR, PC, LR, R12, R0-R3
  261 00000000         ;;              b) Processor mode is switched to Handler
                        mode (from Thread mode)
  262 00000000         ;;              c) Stack is Main stack (switched from Pr
                       ocess stack)
  263 00000000         ;;              d) OSTCBCur      points to the OS_TCB of
                        the task to suspend
  264 00000000         ;;                 OSTCBHighRdy  points to the OS_TCB of
                        the task to resume
  265 00000000         ;;
  266 00000000         ;;           4) Since PendSV is set to lowest priority i
                       n the system (by OSStartHighRdy() above), we
  267 00000000         ;;              know that it will only be run when no ot
                       her exception or interrupt is active, and
  268 00000000         ;;              therefore safe to assume that context be
                       ing switched out was using the process stack (PSP).
  269 00000000         ;;******************************************************
                       **************************************************
  270 00000000         
  271 00000000         ;PendSV_Handler
  272 00000000         ;    CPSID   I                                          
                                ; Prevent interruption during context switch
  273 00000000         ;    MRS     R0, PSP                                    
                                ; PSP is process stack pointer
  274 00000000         ;    CBZ     R0, PendSV_Handler_Nosave                  
                          ; Skip register save the first time
  275 00000000         
  276 00000000         ;    SUBS    R0, R0, #0x20                              
                                ; Save remaining regs r4-11 on process stack
  277 00000000         ;    STM     R0, {R4-R11}
  278 00000000         
  279 00000000         ;    LDR     R1, =OSTCBCur                              
                                ; OSTCBCur->OSTCBStkPtr = SP;
  280 00000000         ;    LDR     R1, [R1]
  281 00000000         ;    STR     R0, [R1]                                   
                                ; R0 is SP of process being switched out
  282 00000000         
  283 00000000         ;                                                       
                                ; At this point, entire context of process has 
                       been saved
  284 00000000         ;PendSV_Handler_Nosave
  285 00000000         ;    PUSH    {R14}                                      
                                ; Save LR exc_return value
  286 00000000         ;    LDR     R0, =OSTaskSwHook                          
                                ; OSTaskSwHook();
  287 00000000         ;    BLX     R0
  288 00000000         ;    POP     {R14}
  289 00000000         
  290 00000000         ;    LDR     R0, =OSPrioCur                             
                                ; OSPrioCur = OSPrioHighRdy;
  291 00000000         ;    LDR     R1, =OSPrioHighRdy



ARM Macro Assembler    Page 8 


  292 00000000         ;    LDRB    R2, [R1]
  293 00000000         ;    STRB    R2, [R0]
  294 00000000         
  295 00000000         ;    LDR     R0, =OSTCBCur                              
                                ; OSTCBCur  = OSTCBHighRdy;
  296 00000000         ;    LDR     R1, =OSTCBHighRdy
  297 00000000         ;    LDR     R2, [R1]
  298 00000000         ;    STR     R2, [R0]
  299 00000000         
  300 00000000         ;    LDR     R0, [R2]                                   
                                ; R0 is new process SP; SP = OSTCBHighRdy->OSTC
                       BStkPtr;
  301 00000000         ;    LDM     R0, {R4-R11}                               
                                ; Restore r4-11 from new process stack
  302 00000000         ;    ADDS    R0, R0, #0x20
  303 00000000         ;    MSR     PSP, R0                                    
                                ; Load PSP with new process SP
  304 00000000         ;    ORR     LR, LR, #0xF4                              
                                ; Ensure exception return uses process stack
  305 00000000         ;    CPSIE   I
  306 00000000         ;    BX      LR                                         
                                ; Exception return will restore remaining conte
                       xt
  307 00000000         
  308 00000000         ;    END
  309 00000000         
  310 00000000         
  311 00000000         
  312 00000000                 IMPORT           OSRunning   ; External referenc
                                                            es
  313 00000000                 IMPORT           OSPrioCur
  314 00000000                 IMPORT           OSPrioHighRdy
  315 00000000                 IMPORT           OSTCBCur
  316 00000000                 IMPORT           OSTCBHighRdy
  317 00000000                 IMPORT           OSIntNesting
  318 00000000                 IMPORT           OSIntExit
  319 00000000                 IMPORT           OSTaskSwHook
  320 00000000         
  321 00000000                 EXPORT           OSStartHighRdy
  322 00000000                 EXPORT           OSCtxSw
  323 00000000                 EXPORT           OSIntCtxSw
  324 00000000                 EXPORT           OS_CPU_SR_Save ; Functions decl
                                                            ared in this file
  325 00000000                 EXPORT           OS_CPU_SR_Restore
  326 00000000                 EXPORT           PendSV_Handler
  327 00000000         
  328 00000000 E000ED04 
                       NVIC_INT_CTRL
                               EQU              0xE000ED04  ; ä¸­æ–­æŽ§åˆ¶å¯„å­
                                                            ˜å™¨
  329 00000000 E000ED22 
                       NVIC_SYSPRI2
                               EQU              0xE000ED22  ; ç³»ç»Ÿä¼˜å…ˆçº§å¯
                                                            „å­˜å™¨(2)
  330 00000000 0000FFFF 
                       NVIC_PENDSV_PRI
                               EQU              0xFFFF      ; PendSVä¸­æ–­å’Œç³
                                                            »ç»ŸèŠ‚æ‹ä¸­æ–­
  331 00000000         ; (éƒ½ä¸ºæœ€ä½Žï¼Œ0xff).



ARM Macro Assembler    Page 9 


  332 00000000 10000000 
                       NVIC_PENDSVSET
                               EQU              0x10000000  ; è§¦å‘è½¯ä»¶ä¸­æ–
                                                            ­çš„å€¼.
  333 00000000         
  334 00000000                 PRESERVE8
  335 00000000                 AREA             |.text|, CODE, READONLY
  336 00000000                 THUMB
  337 00000000         
  338 00000000         
  339 00000000         OS_CPU_SR_Save
  340 00000000 F3EF 8010       MRS              R0, PRIMASK ;è¯»å–PRIMASKåˆ°R0
                                                            ,R0ä¸ºè¿”å›žå€¼ 
  341 00000004 B672            CPSID            I           ;PRIMASK=1,å…³ä¸­æ–
                                                            ­(NMIå’Œç¡¬ä»¶FAULT
                                                            å¯ä»¥å“åº”)
  342 00000006 4770            BX               LR          ;è¿”å›ž
  343 00000008         
  344 00000008         OS_CPU_SR_Restore
  345 00000008 F380 8810       MSR              PRIMASK, R0 ;è¯»å–R0åˆ°PRIMASK
                                                            ä¸­,R0ä¸ºå‚æ•°
  346 0000000C 4770            BX               LR          ;è¿”å›ž
  347 0000000E         
  348 0000000E         ;* åŠŸèƒ½æè¿°: ä½¿ç”¨è°ƒåº¦å™¨è¿è¡Œç¬¬ä¸€ä¸ªä»»åŠ¡
  349 0000000E         OSStartHighRdy
  350 0000000E 4C26            LDR              R4, =NVIC_SYSPRI2 ; set the Pen
                                                            dSV exception prior
                                                            ity
  351 00000010 F64F 75FF       LDR              R5, =NVIC_PENDSV_PRI
  352 00000014 6025            STR              R5, [R4]
  353 00000016 F04F 0400       MOV              R4, #0      ; set the PSP to 0 
                                                            for initial context
                                                             switch call
  354 0000001A F384 8809       MSR              PSP, R4
  355 0000001E 4C23            LDR              R4, =OSRunning 
                                                            ; OSRunning = TRUE
  356 00000020 F04F 0501       MOV              R5, #1
  357 00000024 7025            STRB             R5, [R4]
  358 00000026         ;åˆ‡æ¢åˆ°æœ€é«˜ä¼˜å…ˆçº§çš„ä»»åŠ¡
  359 00000026 4C22            LDR              R4, =NVIC_INT_CTRL ;rigger the 
                                                            PendSV exception (c
                                                            auses context switc
                                                            h)
  360 00000028 F04F 5580       LDR              R5, =NVIC_PENDSVSET
  361 0000002C 6025            STR              R5, [R4]
  362 0000002E         
  363 0000002E B662            CPSIE            I           ;enable interrupts 
                                                            at processor level
  364 00000030         
  365 00000030         OSStartHang
  366 00000030 E7FE            B                OSStartHang ;should never get h
                                                            ere
  367 00000032         
  368 00000032         
  369 00000032         ;* åŠŸèƒ½æè¿°: ä»»åŠ¡çº§ä¸Šä¸‹æ–‡åˆ‡æ¢     
  370 00000032         OSCtxSw
  371 00000032 B430            PUSH             {R4, R5}
  372 00000034 4C1E            LDR              R4, =NVIC_INT_CTRL ;è§¦å‘PendS
                                                            Vå¼‚å¸¸ (causes con



ARM Macro Assembler    Page 10 


                                                            text switch)
  373 00000036 F04F 5580       LDR              R5, =NVIC_PENDSVSET
  374 0000003A 6025            STR              R5, [R4]
  375 0000003C BC30            POP              {R4, R5}
  376 0000003E         
  377 0000003E 4770            BX               LR
  378 00000040         
  379 00000040         ;* åŠŸèƒ½æè¿°: ä¸­æ–­çº§ä»»åŠ¡åˆ‡æ¢
  380 00000040         OSIntCtxSw
  381 00000040 B430            PUSH             {R4, R5}
  382 00000042 4C1B            LDR              R4, =NVIC_INT_CTRL ;è§¦å‘PendS
                                                            Vå¼‚å¸¸ (causes con
                                                            text switch)
  383 00000044 F04F 5580       LDR              R5, =NVIC_PENDSVSET
  384 00000048 6025            STR              R5, [R4]
  385 0000004A BC30            POP              {R4, R5}
  386 0000004C         
  387 0000004C 4770            BX               LR
  388 0000004E BF00            NOP
  389 00000050         
  390 00000050         ;* åŠŸèƒ½æè¿°: OSPendSV is used to cause a context swi
                       tch.
  391 00000050         PendSV_Handler
  392 00000050 B672            CPSID            I           ; Prevent interrupt
                                                            ion during context 
                                                            switch
  393 00000052 F3EF 8009       MRS              R0, PSP     ; PSP is process st
                                                            ack pointer å¦‚æžœå
                                                            œ¨ç”¨PSPå †æ ˆ,åˆ™å
                                                            ¯ä»¥å¿½ç•¥ä¿å­˜å¯
                                                            „å­˜å™¨,å‚è€ƒCM3æ
                                                            ƒå¨ä¸­çš„åŒå †æ ˆ
                                                            
  394 00000056 B150            CBZ              R0, PendSV_Handler_Nosave ; Ski
                                                            p register save the
                                                             first time
  395 00000058 F01E 0F10       TST              R14, #0x10
  396 0000005C BF08            IT               EQ
  397 0000005E         
  398 0000005E ED20 8A10       VSTMDBEQ         R0!, {S16-S31}
  399 00000062 3820            SUBS             R0, R0, #0x20 ; Save remaining 
                                                            regs r4-11 on proce
                                                            ss stack
  400 00000064 E880 0FF0       STM              R0, {R4-R11}
  401 00000068 4912            LDR              R1, =OSTCBCur ; OSTCBCur->OSTCB
                                                            StkPtr = SP;
  402 0000006A 6809            LDR              R1, [R1]
  403 0000006C 6008            STR              R0, [R1]    ; R0 is SP of proce
                                                            ss being switched o
                                                            ut
  404 0000006E         
  405 0000006E         PendSV_Handler_Nosave
  406 0000006E B500            PUSH             {R14}       ; Save LR exc_retur
                                                            n value
  407 00000070 4811            LDR              R0, =OSTaskSwHook 
                                                            ; OSTaskSwHook();
  408 00000072 4780            BLX              R0
  409 00000074 F85D EB04       POP              {R14}
  410 00000078 4810            LDR              R0, =OSPrioCur ; OSPrioCur = OS



ARM Macro Assembler    Page 11 


                                                            PrioHighRdy;
  411 0000007A 4911            LDR              R1, =OSPrioHighRdy
  412 0000007C 780A            LDRB             R2, [R1]
  413 0000007E 7002            STRB             R2, [R0]
  414 00000080 480C            LDR              R0, =OSTCBCur ; OSTCBCur  = OST
                                                            CBHighRdy;
  415 00000082 4910            LDR              R1, =OSTCBHighRdy
  416 00000084 680A            LDR              R2, [R1]
  417 00000086 6002            STR              R2, [R0]
  418 00000088 6810            LDR              R0, [R2]    ; R0 is new process
                                                             SP; SP = OSTCBHigh
                                                            Rdy->OSTCBStkPtr;
  419 0000008A E890 0FF0       LDM              R0, {R4-R11} ; Restore r4-11 fr
                                                            om new process stac
                                                            k
  420 0000008E 3020            ADDS             R0, R0, #0x20
  421 00000090         
  422 00000090         ;Is the task using the FPU context? If so, push high vfp
                        registers.
  423 00000090 F01E 0F10       TST              R14, #0x10
  424 00000094 BF08            IT               EQ
  425 00000096 ECB0 8A10       VLDMIAEQ         R0!, {S16-S31}
  426 0000009A F380 8809       MSR              PSP, R0     ; Load PSP with new
                                                             process SP
  427 0000009E F04E 0E04       ORR              LR, LR, #0x04 ; Ensure exceptio
                                                            n return uses proce
                                                            ss stack
  428 000000A2 B662            CPSIE            I
  429 000000A4 4770            BX               LR          ; Exception return 
                                                            will restore remain
                                                            ing context
  430 000000A6 BF00            NOP
  431 000000A8                 end
              E000ED22 
              00000000 
              E000ED04 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
Command Line: --debug --xref --diag_suppress=9931 --cpu=Cortex-M4.fp --apcs=int
erwork --depend=.\objects\os_cpu_a.d -o.\objects\os_cpu_a.o -I.\RTE\_Target_1 -
IE:\STM32\Keil\ARM\PACK\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32
F4xx\Include -IE:\STM32\Keil\ARM\CMSIS\Include --predefine="__UVISION_VERSION S
ETA 524" --predefine="STM32F401xE SETA 1" --list=.\listings\os_cpu_a.lst Ports\
os_cpu_a.asm



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

.text 00000000

Symbol: .text
   Definitions
      At line 335 in file Ports\os_cpu_a.asm
   Uses
      None
Comment: .text unused
OSCtxSw 00000032

Symbol: OSCtxSw
   Definitions
      At line 370 in file Ports\os_cpu_a.asm
   Uses
      At line 322 in file Ports\os_cpu_a.asm
Comment: OSCtxSw used once
OSIntCtxSw 00000040

Symbol: OSIntCtxSw
   Definitions
      At line 380 in file Ports\os_cpu_a.asm
   Uses
      At line 323 in file Ports\os_cpu_a.asm
Comment: OSIntCtxSw used once
OSStartHang 00000030

Symbol: OSStartHang
   Definitions
      At line 365 in file Ports\os_cpu_a.asm
   Uses
      At line 366 in file Ports\os_cpu_a.asm
Comment: OSStartHang used once
OSStartHighRdy 0000000E

Symbol: OSStartHighRdy
   Definitions
      At line 349 in file Ports\os_cpu_a.asm
   Uses
      At line 321 in file Ports\os_cpu_a.asm
Comment: OSStartHighRdy used once
OS_CPU_SR_Restore 00000008

Symbol: OS_CPU_SR_Restore
   Definitions
      At line 344 in file Ports\os_cpu_a.asm
   Uses
      At line 325 in file Ports\os_cpu_a.asm
Comment: OS_CPU_SR_Restore used once
OS_CPU_SR_Save 00000000

Symbol: OS_CPU_SR_Save
   Definitions
      At line 339 in file Ports\os_cpu_a.asm
   Uses
      At line 324 in file Ports\os_cpu_a.asm
Comment: OS_CPU_SR_Save used once
PendSV_Handler 00000050

Symbol: PendSV_Handler



ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Relocatable symbols

   Definitions
      At line 391 in file Ports\os_cpu_a.asm
   Uses
      At line 326 in file Ports\os_cpu_a.asm
Comment: PendSV_Handler used once
PendSV_Handler_Nosave 0000006E

Symbol: PendSV_Handler_Nosave
   Definitions
      At line 405 in file Ports\os_cpu_a.asm
   Uses
      At line 394 in file Ports\os_cpu_a.asm
Comment: PendSV_Handler_Nosave used once
9 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Absolute symbols

NVIC_INT_CTRL E000ED04

Symbol: NVIC_INT_CTRL
   Definitions
      At line 328 in file Ports\os_cpu_a.asm
   Uses
      At line 359 in file Ports\os_cpu_a.asm
      At line 372 in file Ports\os_cpu_a.asm
      At line 382 in file Ports\os_cpu_a.asm

NVIC_PENDSVSET 10000000

Symbol: NVIC_PENDSVSET
   Definitions
      At line 332 in file Ports\os_cpu_a.asm
   Uses
      At line 360 in file Ports\os_cpu_a.asm
      At line 373 in file Ports\os_cpu_a.asm
      At line 383 in file Ports\os_cpu_a.asm

NVIC_PENDSV_PRI 0000FFFF

Symbol: NVIC_PENDSV_PRI
   Definitions
      At line 330 in file Ports\os_cpu_a.asm
   Uses
      At line 351 in file Ports\os_cpu_a.asm
Comment: NVIC_PENDSV_PRI used once
NVIC_SYSPRI2 E000ED22

Symbol: NVIC_SYSPRI2
   Definitions
      At line 329 in file Ports\os_cpu_a.asm
   Uses
      At line 350 in file Ports\os_cpu_a.asm
Comment: NVIC_SYSPRI2 used once
4 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
External symbols

OSIntExit 00000000

Symbol: OSIntExit
   Definitions
      At line 318 in file Ports\os_cpu_a.asm
   Uses
      None
Comment: OSIntExit unused
OSIntNesting 00000000

Symbol: OSIntNesting
   Definitions
      At line 317 in file Ports\os_cpu_a.asm
   Uses
      None
Comment: OSIntNesting unused
OSPrioCur 00000000

Symbol: OSPrioCur
   Definitions
      At line 313 in file Ports\os_cpu_a.asm
   Uses
      At line 410 in file Ports\os_cpu_a.asm
Comment: OSPrioCur used once
OSPrioHighRdy 00000000

Symbol: OSPrioHighRdy
   Definitions
      At line 314 in file Ports\os_cpu_a.asm
   Uses
      At line 411 in file Ports\os_cpu_a.asm
Comment: OSPrioHighRdy used once
OSRunning 00000000

Symbol: OSRunning
   Definitions
      At line 312 in file Ports\os_cpu_a.asm
   Uses
      At line 355 in file Ports\os_cpu_a.asm
Comment: OSRunning used once
OSTCBCur 00000000

Symbol: OSTCBCur
   Definitions
      At line 315 in file Ports\os_cpu_a.asm
   Uses
      At line 401 in file Ports\os_cpu_a.asm
      At line 414 in file Ports\os_cpu_a.asm

OSTCBHighRdy 00000000

Symbol: OSTCBHighRdy
   Definitions
      At line 316 in file Ports\os_cpu_a.asm
   Uses
      At line 415 in file Ports\os_cpu_a.asm
Comment: OSTCBHighRdy used once
OSTaskSwHook 00000000




ARM Macro Assembler    Page 2 Alphabetic symbol ordering
External symbols

Symbol: OSTaskSwHook
   Definitions
      At line 319 in file Ports\os_cpu_a.asm
   Uses
      At line 407 in file Ports\os_cpu_a.asm
Comment: OSTaskSwHook used once
8 symbols
356 symbols in table
